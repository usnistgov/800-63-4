---
layout: default
title: Session Management
navOrder: 7
navTitle: Session
permalink: /sp800-63b/session/
anchor: sec7
section: 7
---

# Session Management {#sec7}

_This section is normative._

Once an authentication event has taken place, it is often desirable to allow the subscriber to continue using the application across multiple subsequent interactions without requiring them to repeat the authentication event. This requirement is particularly true for federation scenarios — described in [[SP800-63C]](../_sp800-63c/sec1_purpose.md#purpose){:latex-href="#ref-SP800-63C"} — where the authentication event necessarily involves several components and parties coordinating across a network.

To facilitate this behavior, a *session* **MAY** be started in response to an authentication event, and continue the session until such time that it is terminated. The session **MAY** be terminated for any number of reasons, including but not limited to an inactivity timeout, an explicit logout event, or other means. The session **MAY** be continued through a reauthentication event — described in [Sec. 7.2](sec7_session.md#sessionreauthn) — wherein the subscriber repeats some or all of the initial authentication event, thereby re-establishing the session.

Session management is preferable over continual presentation of credentials as the poor usability of continual presentation often creates incentives for workarounds such as caching of activation factors, negating authentication intent and obscuring the freshness of the authentication event.

## Session Bindings

A session occurs between the software that a subscriber is running &mdash; such as a browser, application, or operating system (i.e., the session subject) &mdash; and the RP or CSP that the subscriber is accessing (i.e., the session host). A session secret **SHALL** be shared between the subscriber's software and the service being accessed. This secret binds the two ends of the session, allowing the subscriber to continue using the service over time. The secret **SHALL** be presented directly by the subscriber's software or possession of the secret **SHALL** be proven using a cryptographic mechanism.

Continuity of authenticated sessions **SHALL** be based upon the possession of a session secret issued by the verifier at the time of authentication and optionally refreshed during the session. The nature of a session depends on the application, such as:

* a web browser session with a "session" cookie, or
* an instance of a mobile application that retains a session secret.

Session secrets **SHALL NOT** be persistent (retained across a restart of the associated application or a reboot of the host device).

The secret used for session binding **SHALL** be generated by the session host in direct response to an authentication event. A session **SHOULD** inherit the AAL properties of the authentication event which triggered its creation. A session **MAY** be considered at a lower AAL than the authentication event but **SHALL NOT** be considered at a higher AAL than the authentication event.

Secrets used for session binding **SHALL** meet all of the following requirements:

1. Secrets are generated by the session host during an interaction, typically immediately following authentication.
2. Secrets are generated by an approved random bit generator [[SP800-90Ar1]](references.md#ref-SP800-90Ar1) and contain at least 64 bits of entropy.
3. Secrets are erased or invalidated by the session subject when the subscriber logs out.
4. Secrets are sent to and received from the device using an authenticated protected channel.
5. Secrets will time out and are not accepted after the times specified in [Sections 4.1.3](sec4_aal.md#aal1reauth), [4.2.3](sec4_aal.md#aal2reauth), and [4.3.3](sec4_aal.md#aal3reauth), as appropriate for the AAL.
6. Secrets are not made available to insecure communications between the host and subscriber's endpoint.

In addition, secrets used for session binding **SHOULD** be erased on the subscriber endpoint when they log out or when the secret is deemed to have expired. They **SHOULD NOT** be placed in insecure locations such as HTML5 Local Storage due to the potential exposure of local storage to cross-site scripting (XSS) attacks.

Authenticated sessions **SHALL NOT** fall back to an insecure transport, such as from https to http, following authentication.

URLs or POST content **SHALL** contain a session identifier that **SHALL** be verified by the RP to protect against cross-site request forgery.

There are several mechanisms for managing a session over time. The following sections give different examples along with additional requirements and considerations particular to each example technology. Additional informative guidance is available in the OWASP *Session Management Cheat Sheet* [[OWASP-session]](references.md#ref-OWASP-session).

### Browser Cookies

Browser cookies are the predominant mechanism by which a session will be created and tracked for a subscriber accessing a service. Cookies are not authenticators, but they are suitable as short-term secrets (for the duration of a session).

Cookies used for session maintenance **SHALL** meet all of the following requirements:

1. Cookies are tagged to be accessible only on secure (HTTPS) sessions.
2. Cookies are accessible to the minimum practical set of hostnames and paths.

In addition, session maintenance cookies **SHOULD** be tagged to be inaccessible via JavaScript (HttpOnly). They **SHOULD** contain only an opaque string (such as a session identifier), and **SHOULD NOT** contain cleartext PII. They **SHOULD** be tagged to expire at, or soon after, the session's validity period. This latter requirement is intended to limit the accumulation of cookies, but **SHALL NOT** be depended upon to enforce session timeouts.

### Access Tokens

An access token — such as found in OAuth — is used to allow an application to access a set of services on a subscriber's behalf following an authentication event. The presence of an OAuth access token **SHALL NOT** be interpreted by the RP as presence of the subscriber, in the absence of other signals. The OAuth access token, and any associated refresh tokens, **MAY** be valid long after the authentication session has ended and the subscriber has left the application.

### Device Identification

Other methods of secure device identification &mdash; including but not limited to mutual TLS, token binding, or other mechanisms &mdash; **MAY** be used to enact a session between a subscriber and a service.

## Reauthentication {#sessionreauthn}

Periodic reauthentication of sessions **SHALL** be performed to confirm the continued presence of the subscriber at an authenticated session (i.e., that the subscriber has not walked away without logging out).

A session **SHALL NOT** be extended past the guidelines in Sections [4.1.3](sec4_aal.md#aal1reauth), [4.2.3](sec4_aal.md#aal2reauth), and [4.3.3](sec4_aal.md#aal3reauth) (depending on AAL) based on presentation of the session secret alone. Prior to session expiration, the reauthentication time limit **SHALL** be extended by prompting the subscriber for the authentication factors specified in [Table 2](sec7_session.md#table-2).

When a session has been terminated, due to a time-out or other action, the subscriber **SHALL** be required to establish a new session by authenticating again.

[Table 2 AAL Reauthentication Requirements](sec7_session.md#table-2){:name="table-2"}
{:latex-ignore="true"}

|AAL|Requirement|
|----|----|
|1|Presentation of any one factor|
|2|Presentation of a memorized secret or biometric|
|3|Presentation of all factors|
{:latex-table="2" latex-caption="AAL Reauthentication Requirements"}

>Note: At AAL2, a memorized secret or biometric, and not a physical authenticator, is required because the session secret is *something you have*, and an additional authentication factor is required to continue the session.

### Reauthentication from a Federation or Assertion

When using a federation protocol and Identity Provider (IdP) to authenticate at the RP as described in [[SP800-63C]](../_sp800-63c/sec1_purpose.md#purpose){:latex-href="#ref-SP800-63C"}, special considerations apply to session management and reauthentication. The federation protocol communicates an authentication event at the IdP to the RP using an assertion, and the RP then begins an authenticated session based on the successful validation of this assertion. Since the IdP and RP manage sessions separately from each other and the federation protocol does not connect the session management between the IdP and RP, the termination of the subscriber's sessions at an IdP and at an RP are independent of each other. Likewise, the subscriber's sessions at multiple different RPs are established and terminated independently of each other. 

Consequently, when an RP session expires and the RP requires reauthentication, it is entirely possible that the session at the IdP has not expired and that a new assertion could be generated from this session at the IdP without explicitly reauthenticating the subscriber. The IdP can communicate the time and details of the authentication event to the RP, but it is up to the RP to determine if reauthentication requirements have been met. Section 5.3 of [[SP800-63C]](../_sp800-63c/sec5_federation.md#federation-session){:latex-href="#ref-SP800-63C"} provides additional details and requirements for session management within a federation context.
